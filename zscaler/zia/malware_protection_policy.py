"""
Copyright (c) 2023, Zscaler Inc.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
"""

from zscaler.api_client import APIClient
from zscaler.request_executor import RequestExecutor
from zscaler.zia.models.malware_protection_settings import MalwareSettings
from zscaler.utils import format_url

class MalwareProtectionPolicyAPI(APIClient):
    """
    A Client object for the Malware Protection Policy resource.
    """

    _zia_base_endpoint = "/zia/api/v1"

    def __init__(self, request_executor):
        super().__init__()
        self._request_executor: RequestExecutor = request_executor
        
    def get_atp_malware_policy(self) -> tuple:
        """
        Retrieves the Malware Protection Policy configuration.

        Returns:
            tuple: A tuple containing:
                - dict: The current malware protection policy with keys:
                    - block_unscannable_files (bool): Whether files that cannot be scanned are blocked.
                    - block_password_protected_archive_files (bool): Whether password-protected files are blocked.
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        http_method = "get".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/malwarePolicy
        """)

        request, error = self._request_executor.\
            create_request(http_method, api_url)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            policy_data = response.get_body()
            if not isinstance(policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            malware_policy = {
                "block_unscannable_files": policy_data.get("blockUnscannableFiles", False),
                "block_password_protected_archive_files": policy_data.get("blockPasswordProtectedArchiveFiles", False),
            }
            return (malware_policy, response, None)
        except Exception as ex:
            return (None, response, ex)


    def update_atp_malware_policy(
        self, 
        block_unscannable_files: bool, 
        block_password_protected_archive_files: bool
    ) -> tuple:
        """
        Updates the Malware Protection Policy configuration.

        Args:
            block_unscannable_files (bool): Whether to block unscannable files.
            block_password_protected_archive_files (bool): Whether to block password-protected archive files.

        Returns:
            tuple: A tuple containing:
                - dict: The updated malware protection policy.
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        if not isinstance(block_unscannable_files, bool) or not isinstance(block_password_protected_archive_files, bool):
            raise TypeError("Both arguments must be of type bool.")

        http_method = "put".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/malwarePolicy
        """)

        payload = {
            "blockUnscannableFiles": block_unscannable_files,
            "blockPasswordProtectedArchiveFiles": block_password_protected_archive_files,
        }

        request, error = self._request_executor.\
            create_request(http_method, api_url, payload)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            updated_policy_data = response.get_body()
            if not isinstance(updated_policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            updated_policy = {
                "block_unscannable_files": updated_policy_data.get("blockUnscannableFiles", False),
                "block_password_protected_archive_files": updated_policy_data.get("blockPasswordProtectedArchiveFiles", False),
            }
            return (updated_policy, response, None)
        except Exception as ex:
            return (None, response, ex)

    def get_atp_malware_inspection(self) -> tuple:
        """
        Retrieves the traffic inspection configurations of Malware Protection policy

        Returns:
            tuple: A tuple containing:
                - dict: The current atp malware protection policy inspection with keys:
                    - inspect_inbound (bool): Enables or disables scanning of incoming internet traffic for malicious content
                    - inspect_outbound (bool): Enables or disables scanning of outgoing internet traffic for malicious content
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        http_method = "get".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/atpMalwareInspection
        """)

        request, error = self._request_executor.\
            create_request(http_method, api_url)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            policy_data = response.get_body()
            if not isinstance(policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            malware_policy = {
                "inspect_inbound": policy_data.get("inspectInbound", False),
                "inspect_outbound": policy_data.get("inspectOutbound", False),
            }
            return (malware_policy, response, None)
        except Exception as ex:
            return (None, response, ex)


    def update_atp_malware_inspection(self, inspect_inbound: bool, inspect_outbound: bool) -> tuple:
        """
        Updates the traffic inspection configurations of Malware Protection policy.

        Args:
            - inspect_inbound (bool): Enables or disables scanning of incoming internet traffic for malicious content
            - inspect_outbound (bool): Enables or disables scanning of outgoing internet traffic for malicious content

        Returns:
            tuple: A tuple containing:
                - dict: The updated atp malware protection inspection policy.
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        if not isinstance(inspect_inbound, bool) or not isinstance(inspect_outbound, bool):
            raise TypeError("Both arguments must be of type bool.")

        http_method = "put".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/atpMalwareInspection
        """)

        payload = {
            "inspectInbound": inspect_inbound,
            "inspectOutbound": inspect_outbound,
        }

        request, error = self._request_executor.\
            create_request(http_method, api_url, payload)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            updated_policy_data = response.get_body()
            if not isinstance(updated_policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            updated_policy = {
                "inspect_inbound": updated_policy_data.get("inspectInbound", False),
                "inspect_outbound": updated_policy_data.get("inspectOutbound", False),
            }
            return (updated_policy, response, None)
        except Exception as ex:
            return (None, response, ex)

    def get_atp_malware_protocols(self) -> tuple:
        """
        Retrieves the traffic protocols configurations of Malware Protection policy

        Returns:
            tuple: A tuple containing:
                - dict: The current atp malware protection policy protocols with keys:
                    - inspect_http (bool): Enables or disables scanning of HTTP traffic (and HTTPS traffic if SSL Inspection is enabled) for malicious content in real time
                    - inspect_ftp_over_http (bool): Enables or or disables scanning of FTP over HTTP traffic for malicious content in real time
                    - inspect_ftp (bool): Enables or disables scanning of FTP traffic for malicious content in real time
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        http_method = "get".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/atpMalwareProtocols
        """)

        request, error = self._request_executor.\
            create_request(http_method, api_url)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            policy_data = response.get_body()
            if not isinstance(policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            malware_policy = {
                "inspect_http": policy_data.get("inspectHttp", False),
                "inspect_ftp_over_http": policy_data.get("inspectFtpOverHttp", False),
                "inspect_ftp": policy_data.get("inspectFtp", False),
            }
            return (malware_policy, response, None)
        except Exception as ex:
            return (None, response, ex)


    def update_atp_malware_protocols(
        self, 
        inspect_http: bool, 
        inspect_ftp_over_http: bool,
        inspect_ftp: bool
    ) -> tuple:
        """
        Updates the traffic protocols configurations of Malware Protection policy.

        Args:
            - inspect_http (bool): Enables or disables scanning of HTTP traffic (and HTTPS traffic if SSL Inspection is enabled) for malicious content in real time
            - inspect_ftp_over_http (bool): Enables or or disables scanning of FTP over HTTP traffic for malicious content in real time
            - inspect_ftp (bool): Enables or disables scanning of FTP traffic for malicious content in real time

        Returns:
            tuple: A tuple containing:
                - dict: The updated atp malware protection protocols policy.
                - Response: The raw HTTP response from the API.
                - error: An error message if the request failed, otherwise `None`.
        """
        if not isinstance(inspect_http, bool) or not isinstance(inspect_ftp_over_http, bool ) or not isinstance(inspect_ftp, bool ):
            raise TypeError("Both arguments must be of type bool.")

        http_method = "put".upper()
        api_url = format_url(f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/atpMalwareProtocols
        """)

        payload = {
            "inspectHttp": inspect_http,
            "inspectFtpOverHttp": inspect_ftp_over_http,
            "inspectFtp": inspect_ftp,
        }

        request, error = self._request_executor.\
            create_request(http_method, api_url, payload)
        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)
        if error:
            return (None, response, error)

        try:
            updated_policy_data = response.get_body()
            if not isinstance(updated_policy_data, dict):
                raise ValueError("Unexpected response format: policy data should be a dictionary.")
            
            # Convert camelCase to snake_case
            updated_policy = {
                "inspect_http": updated_policy_data.get("inspectInbound", False),
                "inspect_ftp_over_http": updated_policy_data.get("inspectOutbound", False),
                "inspect_ftp": updated_policy_data.get("inspectFtp", False),
            }
            return (updated_policy, response, None)
        except Exception as ex:
            return (None, response, ex)

    def get_malware_settings(self) -> tuple:
        """
        Retrieves the malware protection policy configuration details

        Returns:
            tuple: A tuple containing:
                - MalwareSettings: The current malware protection policy settings object.
                - Response: The raw HTTP response returned by the API.
                - error: An error message if the request failed; otherwise, `None`.

        Examples:
            Retrieve and print the current malware protection settings:

            >>> settings, response, err = client.zia.malware_protection_settings.get_malware_settings()
            >>> if err:
            ...     print(f"Error fetching settings: {err}")
        """
        http_method = "get".upper()
        api_url = format_url(
            f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/malwareSettings
        """
        )

        request, error = self._request_executor.\
            create_request(
            http_method, api_url
        )

        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)

        if error:
            return (None, response, error)

        try:
            advanced_settings = MalwareSettings(response.get_body())
            return (advanced_settings, response, None)
        except Exception as ex:
            return (None, response, ex)
    
    def update_malware_settings(self, settings: MalwareSettings) -> tuple:
        """
        Updates the malware protection policy configuration details

        Args:
            settings (:obj:`MalwareSettings`): 
                An instance of `MalwareSettings` containing the updated configuration.

                Supported attributes:
                    **Malware Protection Policy Settings:**
                    - **virus_blocked (bool)**: Indicates if malicious programs that cause damage to systems and data are allowed or blocked
                    - **virus_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for viruses
                    - **unwanted_applications_blocked (bool)**: Allows or blocks unwanted files that are downloaded alongside intentional programs downloaded by users
                    - **unwanted_applications_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for unwanted applications                
                    - **trojan_blocked (bool)**: Allows or blocks malicious programs such as Trojan viruses that are presented as beneficial or useful                
                    - **trojan_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for Trojan viruses                   
                    - **worm_blocked (bool)**: Indicates whether malicious programs that duplicate themselves to spread malicious code to other devices are allowed or blocked                   
                    - **worm_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for worms
                    - **adware_blocked (bool)**: Indicates whether malicious files that automatically render advertisements and install adware are allowed or blocked
                    - **adware_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for adware
                    - **spyware_blocked (bool)**: Specifies whether malicious files that covertly gather information about a user or an organization are allowed or blocked
                    - **spyware_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for spyware
                    - **ransomware_blocked (bool)**: Specifies whether to allow or block malicious programs that can encrypt files and prevent users from accessing their devices, files, or data until a ransom payment is made.
                    - **ransomware_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for ransomware
                    - **remote_access_tool_blocked (bool)**: Specifies whether to allow or block file download from tools that are common from remote access sites
                    - **remote_access_tool_capture (bool)**: Specifies whether packet capture (PCAP) is enabled or disabled for remote access tools
                                                                                                                                                                                                        
        Returns:
            tuple: A tuple containing:
                - MalwareSettings: The updated malware protection settings object.
                - Response: The raw HTTP response returned by the API.
                - error: An error message if the update failed; otherwise, `None`.

        Examples:
            Update Malware Settings by enabling Office365 and adjusting the session timeout:

            >>> settings, response, err = client.zia.malware_protection_policy.update_malware_settings()
            >>> if not err:
            ...     settings.virus_blocked = True
            ...     updated_settings, response, err = client.zia.malware_protection_policy.update_malware_settings(settings)
            ...     if not err:
            ...         print(f"Updated Virus Blocked: {updated_settings.virus_blocked}")
            ...     else:
            ...         print(f"Failed to update settings: {err}")
        """
        http_method = "put".upper()
        api_url = format_url(
            f"""
            {self._zia_base_endpoint}
            /cyberThreatProtection/malwareSettings
            """
        )

        payload = settings.request_format()

        request, error = self._request_executor.\
            create_request(http_method, api_url, payload
        )

        if error:
            return (None, None, error)

        response, error = self._request_executor.\
            execute(request)

        if error:
            return (None, response, error)

        # Fetch updated settings from API after successful update
        return self.get_malware_settings()